<!doctype html><html lang=en><head><meta charset=UTF-8><meta content="width=device-width,initial-scale=1.0" name=viewport><link href=https://guylewin.com/rss.xml rel=alternate title=RSS type=application/rss+xml><title>Guy Lewin's Blog | Securing Wedding Website with Nginx</title><link as=style href=https://guylewin.com/css/style.css rel=preload><link crossorigin href=https://raw.githack.com/Speyll/suCSS/main/reset-min.css rel=stylesheet><link crossorigin href=https://raw.githack.com/Speyll/suCSS/main/suCSS-min.css rel=stylesheet><link href=https://guylewin.com/css/style.css rel=stylesheet><link href=https://guylewin.com/css/custom.css rel=stylesheet><link href=https://guylewin.com/favicon.ico rel=icon><script src="https://www.googletagmanager.com/gtag/js?id=G-YEJ89F03YG" async></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());

            gtag('config', 'G-YEJ89F03YG');</script><meta content="Implementing a simple authentication system using Nginx, URL parameters, and cookies to protect a wedding Save the Date website without modifying the frontend." name=description><meta content="Implementing a simple authentication system using Nginx, URL parameters, and cookies to protect a wedding Save the Date website without modifying the frontend." property=og:description><meta content="Implementing a simple authentication system using Nginx, URL parameters, and cookies to protect a wedding Save the Date website without modifying the frontend." name=twitter:description><meta content="nginx, authentication, web-security, wedding-tech, url-parameters, cookies" name=keywords><meta content=Zola name=generator><meta content=English name=language><meta content="index, follow" name=robots><meta content="index, follow" name=googlebot><meta content=en_US property=og:locale><meta content="Guy Lewin's Blog" property=og:site_name><meta content="Guy Lewin's Blog | Securing Wedding Website with Nginx" property=og:title><meta content=https://guylewin.com/blog/2025-01-11-securing-wedding-website-with-nginx/ property=og:url><meta content=article property=og:type><meta content=summary_large_image name=twitter:card><meta content="Guy Lewin's Blog | Securing Wedding Website with Nginx" name=twitter:title><link href=https://guylewin.com/blog/2025-01-11-securing-wedding-website-with-nginx/ rel=canonical><meta content="Guy Lewin" name=author><meta content="Guy Lewin" property=og:author><meta content=2025-01-11T00:00:00Z property=article:published_time><meta content="Guy Lewin" property=article:author><meta content=Blog property=article:section><meta content=nginx property=article:tag><meta content=authentication property=article:tag><meta content=web-security property=article:tag><meta content=wedding-tech property=article:tag><meta content=url-parameters property=article:tag><meta content=cookies property=article:tag><script type=application/ld+json>
{
    "@context": "https://schema.org",
    "@type": "Article",
    "headline": "Securing Wedding Website with Nginx",
    
    "author": {
        "@type": "Person",
        "name": "Guy Lewin"
    },
    
    
    "datePublished": "2025-01-11",
    
    "description": "Implementing a simple authentication system using Nginx, URL parameters, and cookies to protect a wedding Save the Date website without modifying the frontend.",
    "publisher": {
        "@type": "Organization",
        "name": "Guy Lewin&#x27;s Blog"
    }
}
</script><body><nav id=nav-bar><div class=nav-social><a class=icon-link href=https://www.threads.com/@guylewin target=_blank><svg class=icon><use href=https://guylewin.com/icons.svg#threads></use></svg></a><a class=icon-link href=https://www.linkedin.com/in/guy-lewin-48b00712 target=_blank><svg class=icon><use href=https://guylewin.com/icons.svg#linkedin></use></svg></a><a class=icon-link href=https://github.com/GuyLewin target=_blank><svg class=icon><use href=https://guylewin.com/icons.svg#github></use></svg></a><a class=icon-link href=mailto:contact@guylewin.com target=_blank><svg class=icon><use href=https://guylewin.com/icons.svg#email></use></svg></a></div><div class=nav-menu><a href=/> /blog/ </a><a href=/about> /about/ </a></div><div class=nav-controls><div aria-label="Toggle theme" class=theme-toggle data-icon-base=https://guylewin.com/icons.svg data-icon-dark=#darkMode data-icon-light=#lightMode data-sound-src=https://guylewin.com/click.ogg id=theme-toggle role=button tabindex=0><svg class=icon><use id=theme-icon></use></svg></div></div></nav><main><article class=post><header class=post-header><time datetime=2025-01-11>Published on: <span class=accent-data>2025-01-11</span> </time><address rel=author>By <span class=accent-data>Guy Lewin</span></address><h1>Securing Wedding Website with Nginx</h1></header><div class=post-content><p>While planning my wedding, I found myself diving into an interesting technical challenge: how to share our Save the Date website with guests while keeping it private from the general public. This post details how I implemented a simple yet effective authentication system using Nginx, URL parameters, and cookies - without needing to modify the actual website content.<h2 id=the-challenge>The Challenge</h2><p>My partner created a beautiful HTML-based Save the Date website that we wanted to share exclusively with our wedding guests. While the content wasn't particularly sensitive, I preferred to keep it private and away from search engines. The catch? I wanted to maintain the website as pure HTML without adding any authentication code to the frontend.<h2 id=the-solution>The Solution</h2><p>I developed a solution using Nginx that combines three key elements:<ol><li>A password embedded in the URL as a query parameter<li>Browser cookie persistence for a smoother user experience<li>Server-side validation using Nginx configuration</ol><p>When guests receive our Save the Date link (e.g., <code>https://ourwedding.com/save-the-date?pwd=secretkey</code>), Nginx validates the password, sets a persistent cookie, and redirects them to the clean URL. Future visits are authenticated via the cookie, eliminating the need for the query parameter.<h2 id=implementation-details>Implementation Details</h2><p>For this example, let's use <code>aabbccddeeffgg</code> as our URL-friendly password. Here's the Nginx configuration that makes it all work:<pre class=giallo style=color:#e1e4e8;background-color:#24292e><code data-lang=plain><span class=giallo-l><span>location = /robots.txt {</span></span>
<span class=giallo-l><span>    add_header Content-Type text/plain;</span></span>
<span class=giallo-l><span>    return 200 "User-agent: *\nDisallow: /\n";</span></span>
<span class=giallo-l><span>}</span></span>
<span class=giallo-l><span>location ^~ /save-the-date {</span></span>
<span class=giallo-l><span>    # Disable client-side caching </span></span>
<span class=giallo-l><span>    expires -1;</span></span>
<span class=giallo-l><span>    # Set password here</span></span>
<span class=giallo-l><span>    set $password "aabbccddeeffgg";</span></span>
<span class=giallo-l><span>    # Start with empty auth state variable</span></span>
<span class=giallo-l><span>    set $auth_state "";</span></span>
<span class=giallo-l><span>    # Auth state will be set to "q" if query string is correct, empty string otherwise</span></span>
<span class=giallo-l><span>    if ($arg_pwd = $password) {</span></span>
<span class=giallo-l><span>        set $auth_state "q";</span></span>
<span class=giallo-l><span>    }</span></span>
<span class=giallo-l><span>    # Auth state will be set to "qc" if cookie and query string correctly configured, "c" if only cookie, "q" if only query string and empty string if no correct authentication</span></span>
<span class=giallo-l><span>    if ($cookie_pwd = $password) {</span></span>
<span class=giallo-l><span>        set $auth_state "${auth_state}c";</span></span>
<span class=giallo-l><span>    }</span></span>
<span class=giallo-l><span>    # If there has been no correct authentication provided - return 403 Forbidden</span></span>
<span class=giallo-l><span>    if ($auth_state = "") {</span></span>
<span class=giallo-l><span>        return 403;</span></span>
<span class=giallo-l><span>    }</span></span>
<span class=giallo-l><span>    # If the query string was valid (with or without a cookie), set cookie and redirect to the URL without query string</span></span>
<span class=giallo-l><span>    if ($auth_state ~ "qc?") {</span></span>
<span class=giallo-l><span>        add_header Set-Cookie "pwd=${password};Domain=${host};Path=/save-the-date";</span></span>
<span class=giallo-l><span>        return 301 /save-the-date;</span></span>
<span class=giallo-l><span>    }</span></span>
<span class=giallo-l><span>    root /var/www/ourwedding.com/public;</span></span>
<span class=giallo-l><span>    try_files $uri /save-the-date/index.html;</span></span>
<span class=giallo-l><span>}</span></span></code></pre><p>Let's break down how this configuration works:<ol><li><p><strong>Crawler Protection</strong>: A standalone <code>/robots.txt</code> directive ensures search engines won't index the site, regardless of authentication status.</p><li><p><strong>Authentication Logic</strong>: The main directive uses Nginx variables to track authentication state:</p> <ul><li><code>$auth_state</code> can be empty, "q" (valid query string), "c" (valid cookie), or "qc" (both valid)<li>If no valid authentication exists (<code>$auth_state = ""</code>), returns 403 Forbidden<li>When a valid query string is present, sets the cookie and redirects to remove the parameter</ul><li><p><strong>File Serving</strong>: Once authenticated, Nginx serves files from the specified directory, defaulting to <code>index.html</code>.</p></ol><h2 id=future-plans>Future Plans</h2><p>This configuration is part of a larger wedding RSVP system I'm developing. Once I've polished the complete solution, I'll be open-sourcing it for other couples who want to add a technical touch to their wedding planning.<p>Want to implement this for your own event? Just update the password, paths, and domain names in the configuration to match your needs. Just remember to choose a URL-friendly password - I recommend using a hex-encoded / Base64 string for compatibility.</div><div class=post-tags><a class=tag href=/tags/nginx>#nginx</a><a class=tag href=/tags/authentication>#authentication</a><a class=tag href=/tags/web-security>#web-security</a><a class=tag href=/tags/wedding-tech>#wedding-tech</a><a class=tag href=/tags/url-parameters>#url-parameters</a><a class=tag href=/tags/cookies>#cookies</a></div><div class=post-nav><a class=previous href=https://guylewin.com/blog/2025-10-18-automating-secret-santa/><svg class=icon><use href=https://guylewin.com/icons.svg#chevronLeft></use></svg> Next Project</a><a class=next href=https://guylewin.com/blog/2025-01-01-spotify-smart-playlists/>Previous Project <svg class=icon><use href=https://guylewin.com/icons.svg#chevronRight></use></svg></a></div></article></main><footer><hr><div id=footer-container><p>Made using <a rel="noopener noreferrer" href=https://github.com/Speyll/anemone target=_blank>anemone</a> Zola theme</div></footer><script defer src=https://guylewin.com/js/script.js></script>