<!doctype html><html lang=en><head><meta charset=UTF-8><meta content="width=device-width,initial-scale=1.0" name=viewport><link href=https://guylewin.com/rss.xml rel=alternate title=RSS type=application/rss+xml><title>Guy Lewin's Blog | Inconsistencies in grpc-java Error Handling with Bidirectional Streams</title><link as=style href=https://guylewin.com/css/style.css rel=preload><link crossorigin href=https://raw.githack.com/Speyll/suCSS/main/reset-min.css rel=stylesheet><link crossorigin href=https://raw.githack.com/Speyll/suCSS/main/suCSS-min.css rel=stylesheet><link href=https://guylewin.com/css/style.css rel=stylesheet><link href=https://guylewin.com/css/custom.css rel=stylesheet><link href=https://guylewin.com/favicon.ico rel=icon><script src="https://www.googletagmanager.com/gtag/js?id=G-YEJ89F03YG" async></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());

            gtag('config', 'G-YEJ89F03YG');</script><meta content="Investigating error handling behavior in gRPC Java bidirectional streaming, documenting when errors are thrown and how they should be handled in StreamObserver implementations." name=description><meta content="Investigating error handling behavior in gRPC Java bidirectional streaming, documenting when errors are thrown and how they should be handled in StreamObserver implementations." property=og:description><meta content="Investigating error handling behavior in gRPC Java bidirectional streaming, documenting when errors are thrown and how they should be handled in StreamObserver implementations." name=twitter:description><meta content="bidirectional, grpc, grpc-java, oncompleted, onerror, statusruntimeexception, stream, streamobserver" name=keywords><meta content=Zola name=generator><meta content=English name=language><meta content="index, follow" name=robots><meta content="index, follow" name=googlebot><meta content=en_US property=og:locale><meta content="Guy Lewin's Blog" property=og:site_name><meta content="Guy Lewin's Blog | Inconsistencies in grpc-java Error Handling with Bidirectional Streams" property=og:title><meta content=https://guylewin.com/blog/2020-10-27-inconsistencies-in-grpc-java-error-handling-with-bidirectional-streams/ property=og:url><meta content=article property=og:type><meta content=summary_large_image name=twitter:card><meta content="Guy Lewin's Blog | Inconsistencies in grpc-java Error Handling with Bidirectional Streams" name=twitter:title><link href=https://guylewin.com/blog/2020-10-27-inconsistencies-in-grpc-java-error-handling-with-bidirectional-streams/ rel=canonical><meta content="Guy Lewin" name=author><meta content="Guy Lewin" property=og:author><meta content=2020-10-27T00:00:00Z property=article:published_time><meta content="Guy Lewin" property=article:author><meta content=Blog property=article:section><meta content=bidirectional property=article:tag><meta content=grpc property=article:tag><meta content=grpc-java property=article:tag><meta content=oncompleted property=article:tag><meta content=onerror property=article:tag><meta content=statusruntimeexception property=article:tag><meta content=stream property=article:tag><meta content=streamobserver property=article:tag><script type=application/ld+json>
{
    "@context": "https://schema.org",
    "@type": "Article",
    "headline": "Inconsistencies in grpc-java Error Handling with Bidirectional Streams",
    
    "author": {
        "@type": "Person",
        "name": "Guy Lewin"
    },
    
    
    "datePublished": "2020-10-27",
    
    "description": "Investigating error handling behavior in gRPC Java bidirectional streaming, documenting when errors are thrown and how they should be handled in StreamObserver implementations.",
    "publisher": {
        "@type": "Organization",
        "name": "Guy Lewin&#x27;s Blog"
    }
}
</script><body><nav id=nav-bar><div class=nav-social><a class=icon-link href=https://www.threads.com/@guylewin target=_blank><svg class=icon><use href=https://guylewin.com/icons.svg#threads></use></svg></a><a class=icon-link href=https://www.linkedin.com/in/guy-lewin-48b00712 target=_blank><svg class=icon><use href=https://guylewin.com/icons.svg#linkedin></use></svg></a><a class=icon-link href=https://github.com/GuyLewin target=_blank><svg class=icon><use href=https://guylewin.com/icons.svg#github></use></svg></a><a class=icon-link href=mailto:contact@guylewin.com target=_blank><svg class=icon><use href=https://guylewin.com/icons.svg#email></use></svg></a></div><div class=nav-menu><a href=/> /blog/ </a><a href=/about> /about/ </a></div><div class=nav-controls><div aria-label="Toggle theme" class=theme-toggle data-icon-base=https://guylewin.com/icons.svg data-icon-dark=#darkMode data-icon-light=#lightMode data-sound-src=https://guylewin.com/click.ogg id=theme-toggle role=button tabindex=0><svg class=icon><use id=theme-icon></use></svg></div></div></nav><main><article class=post><header class=post-header><time datetime=2020-10-27>Published on: <span class=accent-data>2020-10-27</span> </time><address rel=author>By <span class=accent-data>Guy Lewin</span></address><h1>Inconsistencies in grpc-java Error Handling with Bidirectional Streams</h1></header><div class=post-content><p>While working on a <a href=https://github.com/grpc/grpc-java rel=noopener target=_blank>grpc-java</a> project with <a href=https://grpc.io/docs/languages/java/basics/#bidirectional-streaming-rpc rel=noopener target=_blank>bidirectional streaming</a> I noticed lack of documentation on how to handle errors. I wanted to know when are errors thrown, and how should an error be handled after receiving one.<p>Since I could barely find any documentation online, I constructed a few tests of my own. I arranged a small project with a bidirectional gRPC service, and configured <a href=https://junit.org/ rel=noopener target=_blank>JUnit</a> to perform a successful handshake over the loopback between a client and a server before each test. I was using the most recent version of <code>grpc-java</code> (while writing this post) - <code>1.33.0</code>. There are 4 <code>StreamObserver</code> objects in all the tests:<ul><li>Client Request - Implemented by <code>grpc-java</code>, calling its <code>onNext()</code>, <code>onError()</code> and <code>onCompleted()</code> should trigger the appropriate Server Request <code>StreamObserver</code> object over the network.<li>Client Response - Implemented by me, receiving triggers from Server Response <code>StreamObserver</code> object over the network.<li>Server Request - Implemented by me, receiving triggers from Client Response <code>StreamObserver</code> object over the network.<li>Server Response - Implemented by <code>grpc-java</code>, calling its <code>onNext()</code>, <code>onError()</code> and <code>onCompleted()</code> should trigger the appropriate Client Response <code>StreamObserver</code> object over the network.</ul><p>In the first group of tests - I wanted to check what <code>onError()</code> callbacks are triggered on the <code>StreamObserver</code> objects when I call the 2 different <code>onError()</code> <code>grpc-java</code> implementations. The columns represent the <code>StreamObserver</code> the error was sent on (using <code>onError()</code>). The rows represent the StreamObserver error was checked on (also, using <code>onError()</code>):<table><thead><tr><th><th><strong>Client Request</strong><th><strong>Server Response</strong><tbody><tr><td><strong>Server Request</strong><td><code>StatusRuntimeException("CANCELLED: client cancelled")</code>, <code>cause</code> is <code>null</code>.<td><code>onError()</code> not triggered<tr><td><strong>Client Response</strong><td><code>StatusRuntimeException("CANCELLED: Cancelled by client with StreamObserver.onError()")</code>, original exception included as <code>cause</code>.<td><code>StatusRuntimeException("UNKNOWN")</code>, <code>cause</code> is <code>null</code>.</table><p>(Columns represent the StreamObserver the error was sent on. Rows represent the StreamObserver error was checked on)<p>As you can see - the results are very confusing. Each scenario behaved differently, especially in Server Response <code>StreamObserver</code> object where <code>onError()</code> wasn’t even called when the error was sent from the Server Request object. This proves it is wrong to rely on <code>onError()</code> always being called on both sides when an error is sent.<p>The test above showed us when and how <code>onError()</code> is being triggered on listening <code>StreamObserver</code> objects. But what can (and should) you do with a such object after receiving an error? Should you call <code>onCompleted()</code> manually? Should you call <code>onError()</code> on the corresponding side of the <code>StreamObserver</code>?<p>According to <a href=https://grpc.github.io/grpc-java/javadoc/io/grpc/stub/StreamObserver.html rel=noopener target=_blank>grpc-java’s StreamObserver documentation</a>, <code>onError()</code> and <code>onCompleted()</code> should only be called once and should be the last methods called on an instance. But does that apply if it was called by gRPC over the network? I performed some tests by calling <code>onNext()</code> and <code>onComplete()</code> after throwing errors. These are the results:<table><thead><tr><th><th><strong>Client Request</strong><th><strong>Server Response</strong><tbody><tr><td><strong>Client Request - onNext</strong><td><code>IllegalStateException</code><td>No exception<tr><td><strong>Client Request - onCompleted</strong><td><code>IllegalStateException</code><td>No exception<tr><td><strong>Server Response - onNext</strong><td><code>StatusRuntimeException</code><td><code>IllegalStateException</code><tr><td><strong>Server Response - onCompleted</strong><td>No exception<td><code>IllegalStateException</code></table><p>(Columns represent the StreamObserver the error was sent on. Rows represent the message sent after the error)<p>Once again there are inconsistencies in how gRPC notifies us on the error. It seems like it’s wrong to use the stream after an error was thrown in any way, but only in some cases an exception is thrown back to the caller of <code>onNext()</code> or <code>onCompleted()</code>. I was bothered to see that calling <code>onNext()</code> and <code>onCompleted()</code> on a Server Response <code>StreamObserver</code> object after receiving an error from Client Request side didn’t result in the same exception.<p>In conclusion, based on the tests I performed it appears that:<ul><li>Sending errors from the client to the server will always call <code>onError()</code> on all <code>StreamObserver</code> objects, with informative errors. The other way around isn’t as robust.<li>Streams shouldn’t be used after an error was received, not even to call <code>onCompleted()</code>. gRPC sometimes throws exceptions when calling methods on closed streams.</ul><p>The GitHub repository with all of my tests can be found <a href=https://github.com/GuyLewin/grpc-bidirectional-streaming-error-handling rel=noopener target=_blank>here</a>.</div><div class=post-tags><a class=tag href=/tags/bidirectional>#bidirectional</a><a class=tag href=/tags/grpc>#grpc</a><a class=tag href=/tags/grpc-java>#grpc-java</a><a class=tag href=/tags/oncompleted>#oncompleted</a><a class=tag href=/tags/onerror>#onerror</a><a class=tag href=/tags/statusruntimeexception>#statusruntimeexception</a><a class=tag href=/tags/stream>#stream</a><a class=tag href=/tags/streamobserver>#streamobserver</a></div><div class=post-nav><a class=previous href=https://guylewin.com/blog/2021-07-11-unifi-static-ip-leases/><svg class=icon><use href=https://guylewin.com/icons.svg#chevronLeft></use></svg> Next Project</a><a class=next href=https://guylewin.com/blog/2019-03-16-debugging-webkit-for-ios/>Previous Project <svg class=icon><use href=https://guylewin.com/icons.svg#chevronRight></use></svg></a></div></article></main><footer><hr><div id=footer-container><p>Made using <a rel="noopener noreferrer" href=https://github.com/Speyll/anemone target=_blank>anemone</a> Zola theme</div></footer><script defer src=https://guylewin.com/js/script.js></script>